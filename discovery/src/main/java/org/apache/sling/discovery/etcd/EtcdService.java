/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.sling.discovery.etcd;

import java.io.IOException;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import javax.annotation.Nonnull;

import org.apache.sling.etcd.client.KeyAction;
import org.apache.sling.etcd.client.EtcdClient;
import org.apache.sling.etcd.client.KeyError;
import org.apache.sling.etcd.common.ErrorCodes;
import org.apache.sling.etcd.client.EtcdNode;
import org.apache.sling.etcd.client.EtcdParams;
import org.apache.sling.etcd.client.KeyResponse;
import org.apache.sling.commons.json.JSONException;
import org.apache.sling.commons.json.JSONObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * The {@code EtcdService} provides high level methods to store/retrieve data in etcd in order to implement
 * the Sling discovery API. The data structure in etcd is as follow
 *
 * <ul>
 *     <li>{@code (rootKey)/announces} Folder storing all the announces.</li>
 *     <li>{@code (rootKey)/announces/(uniqueId)} A announce key. The {@code (uniqueId)} is generated by etcd when
 *         creating the announce. Announce keys are created atomically and in order by etcd.
 *         Announces keys contain the Sling identifier of the instance creating them.
 *         In case of announcements using the same Sling identifier, only the first announce (in the creation order)
 *         is kept, the others must be considered invalid and thus discarded.
 *         Announces keys are created with a ttl (Time To Live). The ttl can be refreshed (extended).
 *         Once the ttl is elapsed and if not refreshed, the announce is removed automatically from etcd.
 *         Announces contain a flag {@code lastModified} which indicates (upon any change) that the properties
 *         have changed.</li>
 *     <li>{@code (rootKey)/properties} Folder containing the properties for each instance.</li>
 *     <li>{@code (rootKey)/properties/(slingId)} A properties key, storing the properties for the
 *         instance identified with the {@code slingId}.
 *         Properties keys are permanent (not ttl).</li>
 * </ul>
 */
public class EtcdService {

    private static final Logger LOG = LoggerFactory.getLogger(EtcdService.class);

    private static final String KEY_ANNOUNCES = "/announces";

    private static final String FOLDER_PROPERTIES = "/properties";

    private static final String KEY_PROPERTIES_FORMAT = FOLDER_PROPERTIES + "/%s";

    private static final String UNEXPECTED_ETCD_ERROR_FORMAT = "Unexpected etcd error status: %s %s";

    private final EtcdClient etcdClient;

    private final String rootKey;

    private final EtcdServiceStats errStats;

    /**
     * @param etcdClient the etcd client to communicate with etcd
     * @param rootKey the root key under which all keys/folders will be created.
     *                this key must be a folder in etcd.
     */
    public EtcdService(@Nonnull EtcdClient etcdClient, @Nonnull String rootKey) {
        errStats = new EtcdServiceStats();
        this.rootKey = rootKey;
        this.etcdClient = etcdClient;
    }

    /**
     * Create an announce key for an instance.
     *
     * @param value the announce content.
     * @param announceTtl The time to live (validity in second) for the announce.
     *                    Unless refreshed, the announce will be removed automatically once the ttl provided has elapsed.
     * @return the created announce node.
     * @throws IOException if an I/O error occurred
     * @throws EtcdServiceException if any error was returned from etcd
     */
    @Nonnull
    public EtcdNode createAnnounce(@Nonnull String value, int announceTtl) throws IOException, EtcdServiceException {
        EtcdNode node = throwIfError(internalCreateAnnounce(value, announceTtl)).action().node();
        LOG.debug("Created announce with key: {}, {}", new String[]{node.key(), node.value()});
        return node;
    }

    /**
     * Update the properties key for a given instance.
     *
     * @param properties the properties to be sent.
     * @param slingId the instance identifier to send to the properties for.
     * @return the properties last modified index
     * @throws IOException if an I/O error occurred
     * @throws EtcdServiceException if any error was returned from etcd
     */
    public long sendInstanceProperties(@Nonnull Map<String, String> properties, @Nonnull String slingId) throws IOException, EtcdServiceException {
        JSONObject json = new JSONObject(properties);
        KeyAction action = throwIfError(internalSendProperties(slingId, json.toString())).action();
        long lastModifiedIndex = action.node().modifiedIndex();
        LOG.debug("Sent properties of instance, lastModifiedIndex: " + lastModifiedIndex);
        return lastModifiedIndex;
    }

    /**
     * Get all the announces keys.
     *
     * @return the list (unordered) of announces keys.
     * @throws IOException if an I/O error occurred
     * @throws EtcdServiceException if an unexpected error was returned from etcd
     */
    @Nonnull
    public List<EtcdNode> getAnnounces() throws IOException, EtcdServiceException {
        KeyResponse response = internalGetAnnounces();
        if (response.isAction()) {
            List<EtcdNode> announces = response.action().node().nodes();
            LOG.debug("Found {} announce keys", announces.size());
            return announces;
        } else {
            // expected: key not found (if no announce exists)
            throwIfNoneOf(response.error(), ErrorCodes.KEY_NOT_FOUND);
        }
        return Collections.emptyList();
    }

    /**
     * Get the properties key for a given instance.
     *
     * @param slingId the identifier for the instance to get the properties.
     * @return the map of properties for the given instance. If the required instance does not exist,
     *         an empty map of properties is returned.
     * @throws IOException if an I/O error occurred
     * @throws EtcdServiceException if an unexpected error was returned from etcd
     */
    @Nonnull
    public Map<String, String> getProperties(@Nonnull String slingId) throws IOException, EtcdServiceException {
        KeyResponse response = internalGetProperties(slingId);
        if (response.isAction()) {
            EtcdNode node = response.action().node();
            String key = node.key();
            String value = node.value();
            try {
                JSONObject json = new JSONObject(value);
                return toMap(json);
            } catch (JSONException e) {
                throw new EtcdDiscoveryRuntimeException(String.format("Failed to parse properties for instance: %s", key), e);
            }
        } else {
            // expected: key not found (if no instance properties exist)
            throwIfNoneOf(response.error(), ErrorCodes.KEY_NOT_FOUND);
        }
        return Collections.emptyMap();
    }


    /**
     * Get the properties for all instances in the topology (in a single request).
     *
     * @return the map of properties for each instance, the key is the Sling identifier and
     *         the value is the map of properties
     * @throws IOException if an I/O error occurred
     * @throws EtcdServiceException if an unexpected error was returned from etcd
     */
    @Nonnull
    public Map<String, Map<String, String>> getInstancesProperties() throws IOException, EtcdServiceException {
        KeyResponse response = internalGetAllInstancesProperties();
        Map<String, Map<String, String>> properties = new HashMap<String, Map<String, String>>();
        if (response.isAction()) {
            List<EtcdNode> instances = response.action().node().nodes();
            for (EtcdNode instance : instances) {
                String key = instance.key();
                String value = instance.value();
                try {
                    JSONObject json = new JSONObject(value);
                    properties.put(extractSlingId(key), toMap(json));
                } catch (JSONException e) {
                    throw new EtcdDiscoveryRuntimeException(String.format("Failed to parse properties for instance: %s", key), e);
                }
            }
        } else {
            // expected: key not found (if no instance properties exist)
            throwIfNoneOf(response.error(), ErrorCodes.KEY_NOT_FOUND);
        }
        return properties;
    }

    /**
     * Refresh the ttl of an announce key.
     *
     * @param announceKey the key of the announce to refresh the ttl
     * @param announce the announce content to update.
     * @param announceTtl the announce time to live in seconds.
     * @throws IOException if an I/O error occurred
     * @throws EtcdServiceException if an unexpected error was returned from etcd
     */
    public void refreshAnnounce(@Nonnull String announceKey, @Nonnull String announce, int announceTtl)
            throws IOException, EtcdServiceException {
        throwIfError(internalRefreshAnnounce(announceKey, announce, announceTtl));
    }

    //

    @Nonnull
    public EtcdServiceStats getErrStats() {
        return errStats;
    }

    //

    @Nonnull
    private KeyResponse internalCreateAnnounce(@Nonnull String announce, int announceTtl)
            throws IOException {
        String key = mapKey(KEY_ANNOUNCES);
        LOG.debug("Create announce: {} with ttl: {} at key: {}", new Object[]{announce, announceTtl, key});
        Map<String, String> params = EtcdParams
                .builder()
                .ttl(announceTtl)
                .build();
        try {
            KeyResponse response = etcdClient.postKey(key, announce, params);
            errStats.resetIoError();
            return log(response);
        } catch (IOException e) {
            errStats.increaseIoError();
            throw e;
        }
    }

    @Nonnull
    private KeyResponse internalRefreshAnnounce(@Nonnull String announceKey, @Nonnull String announce, int announceTtl)
            throws IOException {
        LOG.debug("Refresh announce: {} with ttl: {} at key: {}", new Object[]{announce, announceTtl, announceKey});
        Map<String, String> params = EtcdParams
                .builder()
                .prevExist(true)
                .ttl(announceTtl)
                .build();
        try {
            KeyResponse response = etcdClient.putKey(announceKey, announce, params);
            errStats.resetIoError();
            return log(response);
        } catch (IOException e) {
            errStats.increaseIoError();
            throw e;
        }
    }

    /**
     * @return the ordered list of of announce keys.
     * @throws IOException
     */
    @Nonnull
    private KeyResponse internalGetAnnounces() throws IOException {
        String key = mapKey(KEY_ANNOUNCES);
        LOG.debug("Get announces under key: {}", key);
        Map<String, String> params = EtcdParams
                .builder()
                .sorted(true)
                .recursive(true)
                .build();
        try {
            KeyResponse response = etcdClient.getKey(key, params);
            errStats.resetIoError();
            return log(response);
        } catch (IOException e) {
            errStats.increaseIoError();
            throw e;
        }
    }

    @Nonnull
    private KeyResponse internalSendProperties(@Nonnull String slingId, @Nonnull String properties) throws IOException {
        String propertiesKey = String.format(KEY_PROPERTIES_FORMAT, slingId);
        String key = mapKey(propertiesKey);
        LOG.debug("Send properties: {} for slingId: {} at key: {}", new Object[]{properties, slingId, key});
        try {
            KeyResponse response = etcdClient.putKey(key, properties, EtcdParams.noParams());
            errStats.resetIoError();
            return log(response);
        } catch (IOException e) {
            errStats.increaseIoError();
            throw e;
        }
    }

    @Nonnull
    private KeyResponse internalGetProperties(@Nonnull String slingId) throws IOException {
        String propertiesKey = String.format(KEY_PROPERTIES_FORMAT, slingId);
        String key = mapKey(propertiesKey);
        LOG.debug("Get properties for slingId: {} at key: {}", new Object[]{slingId, key});
        Map<String, String> params = EtcdParams
                .builder()
                .recursive(true)
                .build();
        try {
            KeyResponse response = etcdClient.getKey(key, params);
            errStats.resetIoError();
            return log(response);
        } catch (IOException e) {
            errStats.increaseIoError();
            throw e;
        }
    }

    @Nonnull
    private KeyResponse internalGetAllInstancesProperties() throws IOException {
        String key = mapKey(FOLDER_PROPERTIES);
        LOG.debug("Get all instances properties with key: {}", key);
        Map<String, String> params = EtcdParams
                .builder()
                .recursive(true)
                .build();
        try {
            KeyResponse response = etcdClient.getKey(key, params);
            errStats.resetIoError();
            return log(response);
        } catch (IOException e) {
            errStats.increaseIoError();
            throw e;
        }
    }

    /**
     * Throw an {@code EtcdServiceException} exception if the {@code EtcdResponse} is an error.
     *
     * @param response the response to evaluate
     * @return the response passed as parameter, unmodified
     * @throws EtcdServiceException if the {@code EtcdResponse} is an error.
     */
    @Nonnull
    private KeyResponse throwIfError(@Nonnull KeyResponse response) throws EtcdServiceException {
        if (! response.isAction()) {
            KeyError error = response.error();
            int code = error.errorCode();
            String msg = String.format(UNEXPECTED_ETCD_ERROR_FORMAT, code, error.message());
            errStats.increaseEtcdError(code);
            throw new EtcdServiceException(error, msg);
        }
        errStats.resetEtcdError();
        return response;
    }

    /**
     * Throw an {@code EtcdServiceException} exception if the {@code EtcdError} is not of any of the provided codes.
     *
     * @param error the error to evaluate
     * @param expectedCodes the expected code
     * @throws EtcdServiceException if the {@code EtcdError} error's code is none of the #expectedCodes
     */
    private void throwIfNoneOf(@Nonnull KeyError error, int... expectedCodes) throws EtcdServiceException {
        int code = error.errorCode();
        if (noneOf(code, expectedCodes)) {
            String msg = String.format(UNEXPECTED_ETCD_ERROR_FORMAT, code, error.message());
            errStats.increaseEtcdError(code);
            throw new EtcdServiceException(error, msg);
        }
        errStats.resetEtcdError();
    }

    /**
     * @param code the code to match against the set of codes
     * @param codes the set of codes
     * @return {@code true} if the #code if not equals to any of the #codes
     */
    private boolean noneOf(int code, int... codes) {
        for (int c : codes) {
            if (code == c) {
                return false;
            }
        }
        return true;
    }

    @Nonnull
    private static Map<String, String> toMap(@Nonnull JSONObject json) {
        Map<String, String> map = new HashMap<String, String>();
        for (Iterator<String> iter = json.keys() ; iter.hasNext() ; ) {
            String key = iter.next();
            String value = json.optString(key);
            map.put(key, value);
        }
        return map;
    }

    @Nonnull
    private KeyResponse log(@Nonnull KeyResponse response) {
        LOG.trace("Response: {}", response);
        return response;
    }

    @Nonnull
    private String mapKey(String key) {
        return rootKey + key;
    }

    @Nonnull
    private String extractSlingId(@Nonnull String propertyKey) {
        String prefix = String.format("%s%s/", rootKey, FOLDER_PROPERTIES);
        return propertyKey.replaceFirst(prefix, "");
    }
}
